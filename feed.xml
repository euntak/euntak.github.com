<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>euntak.github.io</title>
  
  <subtitle>Better Than Yesterday</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://euntak.github.io/"/>
  <updated>2017-12-01T06:31:51.000Z</updated>
  <id>http://euntak.github.io/</id>
  
  <author>
    <name>euntak</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Typescript Intro</title>
    <link href="http://euntak.github.io/2017/10/25/typescript-basic-1/"/>
    <id>http://euntak.github.io/2017/10/25/typescript-basic-1/</id>
    <published>2017-10-24T15:00:00.000Z</published>
    <updated>2017-12-01T06:31:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Typescript-basic"><a href="#Typescript-basic" class="headerlink" title="Typescript basic"></a>Typescript basic</h1><blockquote><p>Typesciprt는 <em>무료</em> 그리고 Microsoft(이하 MS)에서 개발 및 유지 관리하는 <em>open-source programming language</em>다.</p></blockquote><p>Javascript의 superset이며, 언어에 정적인 타입을 선택적으로 추가할 수 있는 장점이있다.</p><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>TypeScript는 대규모 응용 프로그램을 개발할 때 JavaScript의 단점에서 비롯되어서 개발되었다.</p><p>Javascript 짜여진 프로그램의 규모가 커지면 커질 수록, 복잡한 구조를 가질 수 밖에 없게 되고, 개발을 하는 입장에서 디버깅하기가 매우 까다로워질 수 밖에 없다.</p><blockquote><p>ECMA 曰 “향후에는 class-based programming에 대한 지원을 할꺼야. 이건 표준 문서에도 적혀있는 거란다.”</p></blockquote><p>MS에서는 ECMA의 표준을 지키며 크로스 플랫폼 지원과 호환성을 손상시키지 않는 솔루션을 찾게 되었고, Javascript의 단점들을 보완할 수 있는 추가 확장 기능들을 사용하기 위해서 Basic Javascript로 변환 하는 Compiler를 개발하게 되었다.</p><p>Typescript는 MS에서 내부적으로 2년의 개발기간을 거친 후 2012년에 0.8 버전으로 처음 발표되었다.<br>하지만 OS X와 Linux에서는 사용 할 수 없었고, 지원되는 IDE도 Microsoft Visual Studio밖에 없었기 때문에 부정적으로 평가를 받기도 했다.</p><p>하지만, 2013년에 0.9 버전이 나오면서 플러그인을 통해서 여러 IDE 및 텍스트 편집기들을(Eclipse, Sublime, Vim, Emacs 등등..) 지원할 수 있게되면서 이러한 단점들을 보완하게되었고 추가적으로 Generics도 지원하게 된다.</p><p>이 후, 2014년에 진행된 Microsoft Developer Conference에서 Typescript 1.0가 발표되었고, Visual Studio 2013은 Typescript를 built-in하는 업데이트가 되면서 본격적으로 MS의 Typescript 밀어주기가 시작된 것 같다.</p><p>2014년 7월에는 Compiler가 이전에 비해 5배의 퍼포먼스를 낼 수 있는 만큼 성능이 대폭 상승함과 동시에 CodePlex에서 관리되던 소스코드를 Github으로 옮겼다.</p><p>Typescript는 지속적으로 업데이트 되어 현재 (2017.12.01) 기준 Typescript의 버전은 2.6이다.</p><h2 id="Superset"><a href="#Superset" class="headerlink" title="Superset"></a>Superset</h2><p><img src="/images/venn_typescript_es6_es5.png" alt="superset"></p><p>History를 보면 알다시피 Typescript는 Compiled Language이기 떄문에, Typescript로 작성한 코드는 모두 Javascript로 컴파일 된다. 사실 여기서의 컴파일과 전통적인 컴파일 언어(C,C++,C#,Java…)에서의 컴파일은 차이가 있다. 그렇기 때문에 Transpile이라는 용어를 사용하기도 한다.</p><p><img src="/images/transpiling.png" alt="transpiling"></p><p><a href="https://www.typescriptlang.org/play/index.html" rel="external nofollow noopener noreferrer" target="_blank">Typescript Playground</a> 에서 확인하면 컴파일(Transpile)된 결과물을 볼 수 있다.</p><p><img src="/images/typescript-playground.png" alt="typescript-playground"></p><h2 id="Why-Typescript"><a href="#Why-Typescript" class="headerlink" title="Why Typescript"></a>Why Typescript</h2><p>일단 Javascript에 익숙한 개발자라면 문법적으로 추가된 기능들에 대한 공부만 조금 하면 큰 허들 없이 써볼 수 있는 장점이 있는 것 같다.</p><p>또, 주관적이지만 제품을 만들때에는, 성능도 중요하지만 더 중요한건 안정성인것 같다.<br>아무리 성능이 좋다고 하더라도 제품이 중간에 뻗는 경우가 발생하면 성능은 무용지물이지 않는가. Typescript는 정적타이핑을 통해 얻는 장점들을 Javascript에 적용할 수 있기 때문에 Javasript에 비해 안정성을 어느정도는 보장해주는 것 같다.</p><p>만약 Javascript로 대규모 어플리케이션을 만들 계획을 하고 있다면 Typescript를 추천한다.</p><h2 id="Fuatures"><a href="#Fuatures" class="headerlink" title="Fuatures"></a>Fuatures</h2><ul><li>Type Annotations and compile-time type checking</li><li>Type Interface</li><li>Type erasure</li><li>Interfaces</li><li>Enumerated type</li><li>Mixin</li><li>Generic</li><li>Namespaces</li><li>Tuple</li><li>Await</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Typescript-basic&quot;&gt;&lt;a href=&quot;#Typescript-basic&quot; class=&quot;headerlink&quot; title=&quot;Typescript basic&quot;&gt;&lt;/a&gt;Typescript basic&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;T
      
    
    </summary>
    
      <category term="Typescript" scheme="http://euntak.github.io/categories/Typescript/"/>
    
    
      <category term="Typescript" scheme="http://euntak.github.io/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Function</title>
    <link href="http://euntak.github.io/2017/10/20/javascript-function-definition/"/>
    <id>http://euntak.github.io/2017/10/20/javascript-function-definition/</id>
    <published>2017-10-19T15:00:00.000Z</published>
    <updated>2017-11-28T14:55:55.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javascript-Function-Definition"><a href="#Javascript-Function-Definition" class="headerlink" title="Javascript Function Definition"></a>Javascript Function Definition</h1><p>자바스크립트에서의 함수를 정의하는 방법에 대해서 알아보도록 하겠습니다.</p><ul><li>Function Declaration</li><li>Function Expression</li><li>new Function(param1, param2, body) 객체로 생성하기</li></ul><h3 id="Function-Declaration-함수-선언문"><a href="#Function-Declaration-함수-선언문" class="headerlink" title="Function Declaration (함수 선언문)"></a>Function Declaration (함수 선언문)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">book</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'JS'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function-Expression-함수-표현식"><a href="#Function-Expression-함수-표현식" class="headerlink" title="Function Expression (함수 표현식)"></a>Function Expression (함수 표현식)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> outside = <span class="function"><span class="keyword">function</span> <span class="title">inside</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(param === <span class="number">102</span>) <span class="keyword">return</span> param;</span><br><span class="line">    <span class="keyword">return</span> inside(param + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(outside(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p>자바스크립트 엔진이 해석하는 KEY VALUE 변경 해보면 { outside : { indide : Funtion Object } }</p><h3 id="함수-선언문과-표현식의-차이"><a href="#함수-선언문과-표현식의-차이" class="headerlink" title="함수 선언문과 표현식의 차이"></a>함수 선언문과 표현식의 차이</h3><p>가장 큰 차이점은 <code>Hoisting</code>에 있습니다.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">deff(); <span class="comment">// called deff</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called deff'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">geff(); <span class="comment">// error!</span></span><br><span class="line"><span class="keyword">var</span> geff = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called geff'</span>);</span><br><span class="line">&#125;</span><br><span class="line">geff(); <span class="comment">// called geff</span></span><br></pre></td></tr></table></figure><p>위와 같은 예제에서, <code>deff</code>와 <code>geff</code> 두 함수를 호출할 때에, 함수 표현식으로 선언이 된 geff는 익명의함수가 할당된 다음에 geff()를 호출하게 되면, 정상적으로 작동이 되게 됩니다.</p><p>함수 선언문은 Function Object가 Key, Value로 등록되는 특징상 같은 실행 컨텍스트에서 함수의 이름을 중복해서 작성 할 수 없기 때문에 함수 표현식으로 <code>Namespace</code>를 이용해서 이와 같은 문제를 해결 할 수 있습니다.</p><blockquote><p>함수 선언문은 Hoisting이 되기 때문에, Global Scope로 Function Object가 등록이 되어 어디서든지 사용할 수 있게 되고, 함수 표현식은 Hoisting이 되지 않기 때문에, 해당 변수에 함수를 할당하는 과정 이후에만 사용 할 수 있다.</p></blockquote><h3 id="함수-선언문-오버라이딩"><a href="#함수-선언문-오버라이딩" class="headerlink" title="함수 선언문 오버라이딩"></a>함수 선언문 오버라이딩</h3><p>함수 이름이 같을 때 함수 코드 대체 (replace)</p><ul><li>JS는 파라미터 수, 데이터 타입을 체크하지 않는다<ul><li>Why? Function Object는 {key : value} 형식으로 저장되기 때문</li><li>고로 Function Signiture는 <strong>Only 함수 이름</strong> </li></ul></li><li>초기화 단계에서 함수 선언문을 <code>Funtion Object</code>로 생성</li><li>코드 진행 중, 아래에 이름이 같은 함수 선언문이 있으면 <code>Overriding (replace)</code>된다.</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'first'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'second'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(first()); <span class="comment">// second</span></span><br></pre></td></tr></table></figure><h3 id="Do-it"><a href="#Do-it" class="headerlink" title="Do it"></a>Do it</h3><p>다음과 같이 코드를 작성 했을 때에 예상 결과를 한번 생각해보기.</p><ol><li>함수 선언문 - <code>first()</code> - 함수 선언문</li><li>함수 표현식 - <code>second()</code> - 함수 표현식</li><li>함수 선언문 - <code>third()</code> - 함수 표현식</li><li>함수 표현식 - <code>fourth()</code> - 함수 선언문</li></ol><p><code>debugger;</code>를 통해서 실행 Context 및 순서 확인하기</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'first'</span>); &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(first());</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'first2'</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> second = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'second'</span>); &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(second());</span><br><span class="line">    <span class="keyword">var</span> second = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'second2'</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">third</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'third'</span>); &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(third());</span><br><span class="line">    <span class="keyword">var</span> third = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'third2'</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fourth = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'fourth'</span>); &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(fourth());</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fourth</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'fourth2'</span>); &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>1, 4번의 경우에는 <code>Function Overriding</code>이 일어 난다. 때문에, 함수 표현식에서의 <code>fourth</code>의 값이 JS 엔진에 의해서 초기화 될 때에 <code>undefined</code>가 아닌 이전의 함수 선언문에서 정의 했던 <code>FO</code>가 초기 값이 된다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Javascript-Function-Definition&quot;&gt;&lt;a href=&quot;#Javascript-Function-Definition&quot; class=&quot;headerlink&quot; title=&quot;Javascript Function Definition&quot;&gt;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://euntak.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://euntak.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Hoisting</title>
    <link href="http://euntak.github.io/2017/10/20/javascript-hoisting/"/>
    <id>http://euntak.github.io/2017/10/20/javascript-hoisting/</id>
    <published>2017-10-19T15:00:00.000Z</published>
    <updated>2017-11-28T14:55:55.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javascript-Hoisting"><a href="#Javascript-Hoisting" class="headerlink" title="Javascript Hoisting"></a>Javascript Hoisting</h1><p>Javscript Hoisting을 이해하기 위해서는 먼저 Javascript에서의 함수 정의 방법에 대한 이해가 필요합니다.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sports</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    <span class="keyword">var</span> player = <span class="number">11</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">soccer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> player;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> baseball = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    soccer();</span><br><span class="line">&#125;;</span><br><span class="line">sports();</span><br></pre></td></tr></table></figure><ul><li>위와 같은 코드에서 Javscript Engine은 어떻게 동작할까?<ul><li>모든 Javascript Function은 다음과 같이 동작한다.</li><li>첫번째 cycle 돌면서 <code>함수 선언문</code>을 찾아 FO(function object)을 등록</li><li>두번째 cycle 돌면서 <code>변수 (var)</code>를 찾아 <code>undefined</code>로 초기화</li><li>세번째 cycle 돌면서 JS 코드 해석 및 <code>debugger;</code> 동작</li><li>함수 선언문 해석<ul><li>function sports(){};</li></ul></li><li>변수 초기화<ul><li>var player; // undefined</li><li>var baseball; // undefined</li></ul></li><li>JS 코드 실행<ul><li>debugger;</li><li>var player = 11;</li><li>var baseball = function() {};</li></ul></li></ul></li></ul><blockquote><p>이러한 과정을 “호이스팅(Hoisting)”이라고 칭하며, “var”로 등록된 변수나, “function” 키워드로 등록된 “함수 선언문”이 JS 엔진에 의해서 해석될 때에 “위로 당겨진다(Hoisting)”라는 이유도 이러한 JS 엔진이 코드를 분석하는 특징 때문에 생겨난 개념인 것이다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Javascript-Hoisting&quot;&gt;&lt;a href=&quot;#Javascript-Hoisting&quot; class=&quot;headerlink&quot; title=&quot;Javascript Hoisting&quot;&gt;&lt;/a&gt;Javascript Hoisting&lt;/h1&gt;&lt;p&gt;Ja
      
    
    </summary>
    
      <category term="Javascript" scheme="http://euntak.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://euntak.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript에서의 This</title>
    <link href="http://euntak.github.io/2017/10/19/javascript-this/"/>
    <id>http://euntak.github.io/2017/10/19/javascript-this/</id>
    <published>2017-10-19T07:00:00.000Z</published>
    <updated>2017-11-28T14:55:55.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javscript의-This에-대해서-알아보도록-합시다"><a href="#Javscript의-This에-대해서-알아보도록-합시다" class="headerlink" title="Javscript의 This에 대해서 알아보도록 합시다"></a>Javscript의 This에 대해서 알아보도록 합시다</h1><p>Javascript를 배우면서 <code>this</code> 키워드에 대한 이해가 정말 부족하다고 느꼈었습니다. 특히나.. <code>변할 수 있기 때문</code>입니다.<br>Javascript에서 간단하게 <code>this</code>를 구별할 수 있는 방법, <code>this</code>를 적절하게 사용할 수 있는 방법에 대해서 알아둬야 할 것 같습니다.</p><h3 id="객체에서-function을-호출-할-때에-다음과-같이-합니다"><a href="#객체에서-function을-호출-할-때에-다음과-같이-합니다" class="headerlink" title="객체에서 function을 호출 할 때에 다음과 같이 합니다."></a>객체에서 function을 호출 할 때에 다음과 같이 합니다.</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app = &#123;</span><br><span class="line">    init : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (함수에서 this는 호출하는 주체) 즉, app.init()에서  `.` 앞에 함수를 호출하는 주체가 되는 것이 `this` 대상입니다.</span></span><br><span class="line">app.init();</span><br></pre></td></tr></table></figure><p>위와 같이 있을 때에, <code>init()</code> 내부의 this는 app객체가 되는 것입죠</p><h3 id="그렇다면-호출하는-주체가-없을-때의-this"><a href="#그렇다면-호출하는-주체가-없을-때의-this" class="headerlink" title="그렇다면, 호출하는 주체가 없을 때의 this"></a>그렇다면, 호출하는 주체가 없을 때의 <code>this</code></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 너는 무엇이니</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주체가 없으면 this == window</span></span><br></pre></td></tr></table></figure><p>다음과 같이 <code>setTimeout()</code>, <code>setInterval()</code>과 같은 함수 내에 callback 함수에서의 <code>this</code>는 <strong><code>window</code></strong> 객체를 가리키게 됩니다!</p><h3 id="변할-수-있는-this의-결정-시기"><a href="#변할-수-있는-this의-결정-시기" class="headerlink" title="변할 수 있는 this의 결정 시기"></a><strong>변할 수 있는 this</strong>의 결정 시기</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this는 호출 할 때에 결정 된다. 단, 한번 결정되면 함수가 종료될때까지 변경할 수 없다!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">type, legs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">  <span class="keyword">this</span>.legs = legs;</span><br><span class="line">  <span class="keyword">this</span>.logInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === myCat); <span class="comment">// =&gt; false</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The '</span> + <span class="keyword">this</span>.type + <span class="string">' has '</span> + <span class="keyword">this</span>.legs + <span class="string">' legs'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myCat = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// "The undefined has undefined legs" 출력</span></span><br><span class="line"><span class="comment">// 혹은 엄격모드라면 TypeError 출력</span></span><br><span class="line">setTimeout(myCat.logInfo, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>아마도 setTimeout으로 myCat.logInfo()를 호출할 때, myCat 객체가 출력될 거라고 예상할 수 있습니다. 하지만 setTimeout의 매개변수로 전달되었기 때문에 메소드는 객체로부터 분리 되어있고, 1초 뒤 함수 실행이 되기 때문에, logInfo가 함수로써 실행되기 때문에 여기서의 this는 전역 객체이거나 엄격 모드에서라면 undefined가 됩니다.<br>그렇기 때문에 객체의 정보를 기대한 것대로 출력하지 못합니다.</p><h2 id="this를-고정하는자-bind"><a href="#this를-고정하는자-bind" class="headerlink" title="this를 고정하는자 bind()"></a>this를 고정하는자 bind()</h2><p><code>this</code>를 고정하는 방법에는 여러가지가 있는데, 처음으로 살펴볼 아이는 <code>bind()</code>입니다.</p><p>함수는 <code>bind()</code> 메소드를 사용해 Context(문맥)을 강제로 지정시킬 수 있습니다. 아래와 같이 분리된 메소드가 myCat 객체로 바인딩 된다면 이 문제는 아주 간단하게 해결 할 수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">type, legs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">  <span class="keyword">this</span>.legs = legs;</span><br><span class="line">  <span class="keyword">this</span>.logInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === myCat); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The '</span> + <span class="keyword">this</span>.type + <span class="string">' has '</span> + <span class="keyword">this</span>.legs + <span class="string">' legs'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myCat = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// "The Cat has 4 legs" 출력</span></span><br><span class="line">setTimeout(myCat.logInfo.bind(myCat), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>myCat.logInfo.bind(myCat)는 함수 실행임에도 불구하고, bind()는 return 값이 <strong>함수</strong> 이기 때문에, 첫번째 인자로 등록된 myCat이 주체가 되어 this값을 myCat객체에 고정시켜주는 역할을 하는 것을 볼 수 있습니다.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = &#123;</span><br><span class="line">    init : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bindEvents();</span><br><span class="line">    &#125;,</span><br><span class="line">    bindEvents : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $( <span class="string">"button"</span> ).on( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 여기서의 this는 ELEMENT를 가리킵니다.</span></span><br><span class="line">            $( <span class="keyword">this</span> ).addClass( <span class="string">"active"</span> );</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        $(<span class="string">"h3"</span>).on(<span class="string">"click"</span>, <span class="keyword">this</span>.toggle.bind(<span class="keyword">this</span>, <span class="string">"name"</span>, <span class="string">"props"</span>));</span><br><span class="line">    &#125;,</span><br><span class="line">    toggle : <span class="function"><span class="keyword">function</span>(<span class="params">name, props</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name, props); <span class="comment">// "name", "props"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .bind(context, arg1, arg2, ...)</span></span><br></pre></td></tr></table></figure><p>bind()는 this를 고정하는 역할을 하지만 동시에 해당 callback 함수에 arguments들을 나열하여 필요한 정보를 전달 할 수 있습니다.</p><h3 id="this를-고정하지-않고-arguments를-보내는-방법"><a href="#this를-고정하지-않고-arguments를-보내는-방법" class="headerlink" title="this를 고정하지 않고 arguments를 보내는 방법"></a>this를 고정하지 않고 arguments를 보내는 방법</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"h3"</span>).on(<span class="string">"click"</span>, <span class="keyword">this</span>.toggle.bind(<span class="literal">undefined</span>, <span class="string">"name"</span>, <span class="string">"props"</span>));</span><br></pre></td></tr></table></figure><p>위와 같이 첫번째 인자에 undefined나, null과 같이 의미 없는 것을 인자로 전달하게 되면, this는 고정되지 않고, 인자만 전달할 수 있습니다.</p><h2 id="call-VS-apply"><a href="#call-VS-apply" class="headerlink" title="call() VS apply()"></a>call() VS apply()</h2><p>이번에는 <code>call()</code>과 <code>apply()</code>에 대해서 알아보도록 하겠습니다.<br>bind()는 return 값이 함수인 아이였습니다. 때문에, 콜백을 등록하는데에 용이 했습니다.<br>하지만, call()과 apply()는 bind()와 같이 this를 고정 함과 동시에 <code>함수를 호출</code>하는 녀석들입니다.</p><h3 id="call-과-apply-의-차이점"><a href="#call-과-apply-의-차이점" class="headerlink" title="call()과 apply()의 차이점"></a>call()과 apply()의 차이점</h3><p>간단하게 말해서 this를 고정하는건 공통이지만, 그 뒤에 bind()와 같이 인자로 정보를 넘겨줄수 있는 방식에서 차이점이 있습니다. 앞서 살펴본 bind()에서 인자를 전달하는 방법은 <code>순서대로 나열</code> 하는 방식이였습니다.</p><p>call()을 살펴볼까요?</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure><p>apply()를 살펴볼까요?</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fun.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure><p>자 이제 둘을 비교해보죠, 먼저 call()은 보시는 것 과 같이, 첫번째 인자로 thisArg를 두번째 인자부터는 arg1,2,3..을 받는 것을 확인 할 수 있습니다. 이는 bind()와 같은 형태로 인자를 받는 다는 것을 알 수 있겠네요!</p><p>한마디로 call()에서 인자를 전달하는 방법은 <code>순서대로 나열</code>하는 방식입니다.</p><p>그 다음, apply()를 살펴보면, 2개의 인자만을 받는데, 첫번째로 thisArg 두번째로는 [argsArray]를 받는 걸로 봐서 인자를 <code>배열 형태</code>로 <code>하나</code>만 받는 것을 알 수 있겠네요!</p><p>한마디로 apply()에서 인자를 전달하는 방법은 <code>여러 가지 인자를 하나의 배열 형태로 받는</code> 방식입니다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>this, bind, call, apply등을 알아봤는데, 이번 기회를 통해서 조금 애매했던 기능들의 차이점, 역할에 대해서 조금 더 명확하게 알 수 있었으면 좋겠습니다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" rel="external nofollow noopener noreferrer" target="_blank">bind</a> </li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="external nofollow noopener noreferrer" target="_blank">apply</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="external nofollow noopener noreferrer" target="_blank">call</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this" rel="external nofollow noopener noreferrer" target="_blank">this</a></li><li><a href="https://developer.mozilla.org/ko/docs/Glossary/Hoisting" rel="external nofollow noopener noreferrer" target="_blank">hoisting</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="external nofollow noopener noreferrer" target="_blank">event loop</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Javscript의-This에-대해서-알아보도록-합시다&quot;&gt;&lt;a href=&quot;#Javscript의-This에-대해서-알아보도록-합시다&quot; class=&quot;headerlink&quot; title=&quot;Javscript의 This에 대해서 알아보도록 합시다&quot;&gt;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://euntak.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://euntak.github.io/tags/Javascript/"/>
    
  </entry>
  
</feed>
