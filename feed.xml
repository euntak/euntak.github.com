<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>euntak.github.io</title>
  
  <subtitle>Better Than Yesterday</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://euntak.github.io/"/>
  <updated>2017-12-01T09:53:55.000Z</updated>
  <id>http://euntak.github.io/</id>
  
  <author>
    <name>euntak</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Typescript Basic Types</title>
    <link href="http://euntak.github.io/2017/12/01/typescript-basic-type-md/"/>
    <id>http://euntak.github.io/2017/12/01/typescript-basic-type-md/</id>
    <published>2017-12-01T06:44:39.000Z</published>
    <updated>2017-12-01T09:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Typescript-Basic-Types"><a href="#Typescript-Basic-Types" class="headerlink" title="Typescript Basic Types"></a>Typescript Basic Types</h1><p>Typescript-Intro에서 Typescript는 Javascript의 superset이라고 소개했다.<br><strong>그래서 Javascript의 기본 자료형들을 모두 포함한다.</strong></p><p>사용자가 만든 커스텀한 타입들은 결국에 이러한 기본 자료형으로 쪼개지기 때문에 Typescript의 정적 타이핑의 이점을 제대로 활용하기 위해서 반드시 알고 넘어가야한다고 생각되어 살짝 정리해보았다.</p><p>우선 Javascript의 기본 자료형을 살펴보자.</p><ul><li>Boolean</li><li>Number</li><li>String</li><li>Null</li><li>Undefined</li><li>Symbol (ES6)</li><li>Array (Object)</li></ul><p>Typescript는 위와 동일한 타입을 가지고있으며, 아래와 같이 추가타입을 지원한다.</p><ul><li>Any</li><li>Void</li><li>Never</li><li>Enum</li><li>Tuple (Object)</li></ul><h2 id="Primitive-Type"><a href="#Primitive-Type" class="headerlink" title="Primitive Type"></a>Primitive Type</h2><p>Object를 제외한 모든 유형은 변경이 불가능한 값을 정의한다.<br>레퍼런스 형태가 아닌 실제 값을 저장하는 자료형이다.</p><p>자세한 내용은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures" rel="external nofollow noopener noreferrer" target="_blank">Javascript Primitive Values</a>를 참고하길 바란다.</p><h2 id="Literal"><a href="#Literal" class="headerlink" title="Literal"></a>Literal</h2><p>JavaScript에서 값을 나타내기 위해 리터럴을 사용한다. 이는 말 그대로 스크립트에 부여한 고정값으로, 변수가 아니다. 상수는 가리키는 포인터가 고정이라는 점, 리터럴은 그 자체가 값이자 그릇이다.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>]; <span class="comment">// array literal</span></span><br><span class="line"><span class="string">'troflev'</span> <span class="comment">// string literal</span></span><br><span class="line"><span class="literal">true</span> <span class="comment">// boolean literal</span></span><br><span class="line">&#123; <span class="attr">obj</span> : <span class="string">'obj'</span> &#125; <span class="comment">// object literal</span></span><br><span class="line"><span class="number">10</span> <span class="comment">// number literal</span></span><br></pre></td></tr></table></figure><p>이러한 값들을 리터럴이라고 하는 이유는 프로그램 내에 직접 문자형태로 지정되는 값들이기 때문이다.<br>이러한 값들은 한번 지정되면 변하지 않고, 그 값을 변경 할 수 없기 때문이다.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>예를 들어, 다음과 같이 first 변수에 할당된 <code>1</code>은 그 자체가 값이면서 프로그램내에서 값을 변경 할 수 없기 때문에 이러한 값들을 <strong>리터럴 상수</strong>라고 부른다.</p><p>마찬가지로 자세한 내용은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#Array_literals" rel="external nofollow noopener noreferrer" target="_blank">Javascript Literal</a>을 참고하길 바란다.</p><h2 id="Wrapper-Object-VS-Primitive-type"><a href="#Wrapper-Object-VS-Primitive-type" class="headerlink" title="Wrapper Object VS Primitive type"></a>Wrapper Object VS Primitive type</h2><p>Boolean은 boolean을 래핑한 객체이고, 해당 primitive값을 편리하게 사용하기 위해 <code>toString(), valueOf()</code>와 같은 내장 함수들을 제공한다.<br>boolean은 primitive type이며, Boolean 객체에 할당 할 수 없다.</p><p>위 두 타입 중 <code>boolean</code>의 사용을 권장하는 편이다. 래핑된 객체 Boolean으로 생성한 값을 boolean으로 할당할 수는 있으나, boolean으로 생성한 값을 Boolean으로 할당 할 수 없기 때문이다.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> boolean1 : boolean = <span class="keyword">new</span> Boolen(<span class="literal">true</span>); <span class="comment">// Allow</span></span><br><span class="line"><span class="keyword">const</span> boolean2 : <span class="built_in">Boolean</span> = <span class="literal">true</span>; <span class="comment">// Error: Type 'Boolean' is not assignable to type 'boolean'.</span></span><br><span class="line"><span class="comment">// 'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.</span></span><br></pre></td></tr></table></figure><p>위의 예제를 보면, <strong>boolean1</strong>은 <code>boolean</code> 타입을 지정하여 Wrapper Object인 <code>new Boolean(true)</code>을 받을 수 있지만, <strong>boolean2</strong>에서 볼 수 있듯이 받는 타입을 Boolean으로 지정하면 <code>true</code>값을 받지 못한다. 때문에 가능하면 boolean을 사용하라고 권장한다. (Javascript, Typescript)</p><p><code>Number / number , String / string</code>에서도 동일하게 적용된다.</p><p>참고로 <a href="https://github.com/airbnb/javascript" rel="external nofollow noopener noreferrer" target="_blank">Airbnb Javascript Style Guide</a>를 보면, Javascript에서 Wrapper Object로 값을 생성하는 것 보다 리터럴로 값을 생성하는 것을 권장한다.</p><p>이제 본격적으로 Typescript에서 제공하는 기본 타입에 대한 것들을 알아보자.</p><h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>이름으로 유추할 수 있듯이 <code>어떤 타입이어도 상관 없다</code>라는 뜻이다.<br>Typescript Compile option에서 <code>noImplicitAny</code> 옵션을 사용하여 any를 쓰면 오류를 발생시키도록 하는 옵션을 지정 할 수 있다.</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInfo &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    address: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type '&#123; name: string; address: string; &#125;' is not assignable to type 'UserInfo'.</span></span><br><span class="line"><span class="comment">// Property 'age' is missing in type '&#123; name: string; address: string; &#125;'.</span></span><br><span class="line"><span class="keyword">const</span> User1: UserInfo = &#123;</span><br><span class="line">    name: <span class="string">'name'</span>,</span><br><span class="line">    address: <span class="string">'address'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow</span></span><br><span class="line"><span class="keyword">const</span> User2: <span class="built_in">any</span> = &#123;</span><br><span class="line">    name: <span class="string">'name'</span>,</span><br><span class="line">    address: <span class="string">'address'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>위의 예제를 살펴보면, User1은 타입이 <code>UserInfo</code>이고, User2는 <code>any</code>타입을 가진 객체이다.<br><strong>User1</strong>에서는 타입 체크가 통과되지 못하여 컴파일 단계에서 주석과 같은 에러를 발생시키고, <strong>User2</strong>에서는 타입이 any로 되어 있으므로, <code>User2에는 아무 값이나 넣어도 문제 없어</code>라는 말과 같기 때문에 아무런 에러를 발생시키지 않는다.</p><p><del>그렇기 때문에 Typescript를 제대로 활용하기 위해서는 <code>any</code>를 최대한 사용하지 않는 것!</del><br>Typescript가 계속적으로 발전하고, IDE나 텍스트 편집기 툴들이 많이 발전하면서 자동으로 Type을 유추해주는 기능들이 발전하고 있다. 때문에 any를 사용해도 그렇게 크게 문제가 될만한 이슈들이 발생하지 않을 수 있게되었지만 <strong>그래도 최대한 안쓰는 걸로.</strong> (Type을 명시해 주면 코드를 읽는 사람들이 빠르게 타입을 유추할 수 있는 이점도 있기도 하고.. 기타 등등..)</p><h2 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h2><p>C, Java를 사용해봤다면 익숙한 keyword이다. Typescript에서도 동일한 쓰임새를 보인다. 보통 함수의 리턴 형식을 지정할 때 사용한다.</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printErrorLog</span>(<span class="params">error: ErrorType</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Error : '</span>, error);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 error log를 출력하고 리턴 값이 없는 함수의 경우 <code>void</code> 타입을 명시적으로 지정해 줄 수 있다.<br><code>void</code>는 <code>null</code>, <code>undefined</code> 값을 가질 수 있기 때문에, 함수 리턴에 null과 undefined를 지정 할 수 있다.</p><h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p>얘는 왜 있는 타입인지 모르겠다. 사실 써본적이 없다. <code>void</code>와 비슷한 특정을 가지고 있지만, 얘는 null과 undefined를 모두 허용하지 않는다. <code>any</code>와 반대되는 타입이다. 모든 것을 허용하지 않는 타입.</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function returning never must have unreachable end point</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inferred return type is never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function returning never must have unreachable end point</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><p>이 Keyword도 익숙한 부분이 있다. <code>Enumertaion</code>을 생각하면 될 듯 하다.</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Coffee &#123;</span><br><span class="line">    Espresso,</span><br><span class="line">    Americano,</span><br><span class="line">    Latte</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> favoriteCoffe = Coffee.Americano; <span class="comment">// 'Americano'</span></span><br></pre></td></tr></table></figure><p>Enum type은 <a href="https://www.typescriptlang.org/play/index.html" rel="external nofollow noopener noreferrer" target="_blank">Typescript Playground</a>에서 실행 해보면 약간 복잡한 Javascript code로 변환되는데 잠깐 살펴보자.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Coffee;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Coffee</span>) </span>&#123;</span><br><span class="line">    Coffee[Coffee[<span class="string">"Espresso"</span>] = <span class="number">0</span>] = <span class="string">"Espresso"</span>;</span><br><span class="line">    Coffee[Coffee[<span class="string">"Americano"</span>] = <span class="number">1</span>] = <span class="string">"Americano"</span>;</span><br><span class="line">    Coffee[Coffee[<span class="string">"Latte"</span>] = <span class="number">2</span>] = <span class="string">"Latte"</span>;</span><br><span class="line">&#125;)(Coffee || (Coffee = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> favoriteCoffe = Coffee.Americano; <span class="comment">// 'Americano'</span></span><br></pre></td></tr></table></figure><p><code>Enum type</code>은 위와 같은 IIFE(Immediately-invoked function expression) 형식으로 변환이 된다.</p><p>위의 코드를 크롬 브라우저 콘솔에서 실행시킨 결과 값이다.</p><p><img src="/images/typescript-enum.png" alt="enum-test"><br><a href="https://stackoverflow.com/questions/20278095/enums-in-typescript-what-is-the-javascript-code-doing" rel="external nofollow noopener noreferrer" target="_blank">이와 같은 결과를 나타내는 이유</a></p><h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>Tuple은 DB에서 주로 들어본 keyword인데, 그 의미가 완전 다르다.<br>Typescript에서의 Tuple은 배열의 종류로서 타입이 한가지가 아닌 여러 타입을 허용하는 특이한 배열이다. 배열이므로 수정과 삭제 추가가 가능한 특징을 갖는다.</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tuplex: [ <span class="built_in">boolean</span>, <span class="built_in">number</span> ] = [<span class="literal">false</span>, <span class="number">100</span>];</span><br><span class="line">tuplex.concat([ <span class="literal">true</span>, <span class="number">200</span> ]);</span><br><span class="line">tuple.push(<span class="string">'string'</span>); <span class="comment">// Argument of type '"string"' is not assignable to parameter of type 'number | boolean'.</span></span><br><span class="line">tuplex.push([<span class="number">100</span>, <span class="literal">true</span>]); <span class="comment">// Argument of type '(number | boolean)[]' is not assignable to parameter of type 'number | boolean'. Type '(number | boolean)[]' is not assignable to type 'false'.</span></span><br><span class="line">tuplex.push([<span class="number">100</span>]); <span class="comment">// Argument of type 'number[]' is not assignable to parameter of type 'number | boolean'. Type 'number[]' is not assignable to type 'false'.</span></span><br></pre></td></tr></table></figure><p>위와 같은 예제를 보면, 배열의 타입을 지정 할 수 있다. 각 타입이 지정된 배열의 <code>순서대로</code> arguments들이 들어와야 하며, 지정된 타입 외에 <code>다른 타입의 값을 할당할 수 없다</code>. 또한 처음 <code>선언된 타입의 개수만큼</code> arguments들이 지정 되어야 한다.</p><hr><p>오늘은, Typescript의 기본 타입들을 살펴보았다. 개인적으로 Typescript를 공부하면서 적은 글이라 설명이 많이 부족한 것 같다. 이 글을 읽으면서 부족한 점이 있거나 틀린점이 있다면 언제든지 지적해주길 바란다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Typescript-Basic-Types&quot;&gt;&lt;a href=&quot;#Typescript-Basic-Types&quot; class=&quot;headerlink&quot; title=&quot;Typescript Basic Types&quot;&gt;&lt;/a&gt;Typescript Basic Typ
      
    
    </summary>
    
      <category term="Typescript" scheme="http://euntak.github.io/categories/Typescript/"/>
    
    
      <category term="Typescript" scheme="http://euntak.github.io/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript Intro</title>
    <link href="http://euntak.github.io/2017/12/01/typescript-intro/"/>
    <id>http://euntak.github.io/2017/12/01/typescript-intro/</id>
    <published>2017-11-30T15:00:00.000Z</published>
    <updated>2017-12-01T06:45:11.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Typescript-Intro"><a href="#Typescript-Intro" class="headerlink" title="Typescript Intro"></a>Typescript Intro</h1><blockquote><p>Typesciprt는 <em>무료</em> 그리고 Microsoft(이하 MS)에서 개발 및 유지 관리하는 <em>open-source programming language</em>다.</p></blockquote><p>Javascript의 superset이며, 언어에 정적인 타입을 선택적으로 추가할 수 있는 장점이있다.</p><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>TypeScript는 대규모 응용 프로그램을 개발할 때 JavaScript의 단점에서 비롯되어서 개발되었다.</p><p>Javascript 짜여진 프로그램의 규모가 커지면 커질 수록, 복잡한 구조를 가질 수 밖에 없게 되고, 개발을 하는 입장에서 디버깅하기가 매우 까다로워질 수 밖에 없다.</p><blockquote><p>ECMA 曰 “향후에는 class-based programming에 대한 지원을 할꺼야. 이건 표준 문서에도 적혀있는 거란다.”</p></blockquote><p>MS에서는 ECMA의 표준을 지키며 크로스 플랫폼 지원과 호환성을 손상시키지 않는 솔루션을 찾게 되었고, Javascript의 단점들을 보완할 수 있는 추가 확장 기능들을 사용하기 위해서 Basic Javascript로 변환 하는 Compiler를 개발하게 되었다.</p><p>Typescript는 MS에서 내부적으로 2년의 개발기간을 거친 후 2012년에 0.8 버전으로 처음 발표되었다.<br>하지만 OS X와 Linux에서는 사용 할 수 없었고, 지원되는 IDE도 Microsoft Visual Studio밖에 없었기 때문에 부정적으로 평가를 받기도 했다.</p><p>하지만, 2013년에 0.9 버전이 나오면서 플러그인을 통해서 여러 IDE 및 텍스트 편집기들을(Eclipse, Sublime, Vim, Emacs 등등..) 지원할 수 있게되면서 이러한 단점들을 보완하게되었고 추가적으로 Generics도 지원하게 된다.</p><p>이 후, 2014년에 진행된 Microsoft Developer Conference에서 Typescript 1.0가 발표되었고, Visual Studio 2013은 Typescript를 built-in하는 업데이트가 되면서 본격적으로 MS의 Typescript 밀어주기가 시작된 것 같다.</p><p>2014년 7월에는 Compiler가 이전에 비해 5배의 퍼포먼스를 낼 수 있는 만큼 성능이 대폭 상승함과 동시에 CodePlex에서 관리되던 소스코드를 Github으로 옮겼다.</p><p>Typescript는 지속적으로 업데이트 되어 현재 (2017.12.01) 기준 Typescript의 버전은 2.6이다.</p><h2 id="Superset"><a href="#Superset" class="headerlink" title="Superset"></a>Superset</h2><p><img src="/images/venn_typescript_es6_es5.png" alt="superset"></p><p>History를 보면 알다시피 Typescript는 Compiled Language이기 떄문에, Typescript로 작성한 코드는 모두 Javascript로 컴파일 된다. 사실 여기서의 컴파일과 전통적인 컴파일 언어(C,C++,C#,Java…)에서의 컴파일은 차이가 있다. 그렇기 때문에 Transpile이라는 용어를 사용하기도 한다.</p><p><img src="/images/transpiling.png" alt="transpiling"></p><p><a href="https://www.typescriptlang.org/play/index.html" rel="external nofollow noopener noreferrer" target="_blank">Typescript Playground</a> 에서 확인하면 컴파일(Transpile)된 결과물을 볼 수 있다.</p><p><img src="/images/typescript-playground.png" alt="typescript-playground"></p><h2 id="Why-Typescript"><a href="#Why-Typescript" class="headerlink" title="Why Typescript"></a>Why Typescript</h2><p>일단 Javascript에 익숙한 개발자라면 문법적으로 추가된 기능들에 대한 공부만 조금 하면 큰 허들 없이 써볼 수 있는 장점이 있는 것 같다.</p><p>또, 주관적이지만 제품을 만들때에는, 성능도 중요하지만 더 중요한건 안정성인것 같다.<br>아무리 성능이 좋다고 하더라도 제품이 중간에 뻗는 경우가 발생하면 성능은 무용지물이지 않는가. Typescript는 정적타이핑을 통해 얻는 장점들을 Javascript에 적용할 수 있기 때문에 Javasript에 비해 안정성을 어느정도는 보장해주는 것 같다.</p><p>만약 Javascript로 대규모 어플리케이션을 만들 계획을 하고 있다면 Typescript를 추천한다.</p><h2 id="Fuatures"><a href="#Fuatures" class="headerlink" title="Fuatures"></a>Fuatures</h2><ul><li>Type Annotations and compile-time type checking</li><li>Type Interface</li><li>Type erasure</li><li>Interfaces</li><li>Enumerated type</li><li>Mixin</li><li>Generic</li><li>Namespaces</li><li>Tuple</li><li>Await</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Typescript-Intro&quot;&gt;&lt;a href=&quot;#Typescript-Intro&quot; class=&quot;headerlink&quot; title=&quot;Typescript Intro&quot;&gt;&lt;/a&gt;Typescript Intro&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;T
      
    
    </summary>
    
      <category term="Typescript" scheme="http://euntak.github.io/categories/Typescript/"/>
    
    
      <category term="Typescript" scheme="http://euntak.github.io/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Function</title>
    <link href="http://euntak.github.io/2017/10/20/javascript-function-definition/"/>
    <id>http://euntak.github.io/2017/10/20/javascript-function-definition/</id>
    <published>2017-10-19T15:00:00.000Z</published>
    <updated>2017-11-28T14:55:55.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javascript-Function-Definition"><a href="#Javascript-Function-Definition" class="headerlink" title="Javascript Function Definition"></a>Javascript Function Definition</h1><p>자바스크립트에서의 함수를 정의하는 방법에 대해서 알아보도록 하겠습니다.</p><ul><li>Function Declaration</li><li>Function Expression</li><li>new Function(param1, param2, body) 객체로 생성하기</li></ul><h3 id="Function-Declaration-함수-선언문"><a href="#Function-Declaration-함수-선언문" class="headerlink" title="Function Declaration (함수 선언문)"></a>Function Declaration (함수 선언문)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">book</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'JS'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function-Expression-함수-표현식"><a href="#Function-Expression-함수-표현식" class="headerlink" title="Function Expression (함수 표현식)"></a>Function Expression (함수 표현식)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> outside = <span class="function"><span class="keyword">function</span> <span class="title">inside</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(param === <span class="number">102</span>) <span class="keyword">return</span> param;</span><br><span class="line">    <span class="keyword">return</span> inside(param + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(outside(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p>자바스크립트 엔진이 해석하는 KEY VALUE 변경 해보면 { outside : { indide : Funtion Object } }</p><h3 id="함수-선언문과-표현식의-차이"><a href="#함수-선언문과-표현식의-차이" class="headerlink" title="함수 선언문과 표현식의 차이"></a>함수 선언문과 표현식의 차이</h3><p>가장 큰 차이점은 <code>Hoisting</code>에 있습니다.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">deff(); <span class="comment">// called deff</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called deff'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">geff(); <span class="comment">// error!</span></span><br><span class="line"><span class="keyword">var</span> geff = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called geff'</span>);</span><br><span class="line">&#125;</span><br><span class="line">geff(); <span class="comment">// called geff</span></span><br></pre></td></tr></table></figure><p>위와 같은 예제에서, <code>deff</code>와 <code>geff</code> 두 함수를 호출할 때에, 함수 표현식으로 선언이 된 geff는 익명의함수가 할당된 다음에 geff()를 호출하게 되면, 정상적으로 작동이 되게 됩니다.</p><p>함수 선언문은 Function Object가 Key, Value로 등록되는 특징상 같은 실행 컨텍스트에서 함수의 이름을 중복해서 작성 할 수 없기 때문에 함수 표현식으로 <code>Namespace</code>를 이용해서 이와 같은 문제를 해결 할 수 있습니다.</p><blockquote><p>함수 선언문은 Hoisting이 되기 때문에, Global Scope로 Function Object가 등록이 되어 어디서든지 사용할 수 있게 되고, 함수 표현식은 Hoisting이 되지 않기 때문에, 해당 변수에 함수를 할당하는 과정 이후에만 사용 할 수 있다.</p></blockquote><h3 id="함수-선언문-오버라이딩"><a href="#함수-선언문-오버라이딩" class="headerlink" title="함수 선언문 오버라이딩"></a>함수 선언문 오버라이딩</h3><p>함수 이름이 같을 때 함수 코드 대체 (replace)</p><ul><li>JS는 파라미터 수, 데이터 타입을 체크하지 않는다<ul><li>Why? Function Object는 {key : value} 형식으로 저장되기 때문</li><li>고로 Function Signiture는 <strong>Only 함수 이름</strong> </li></ul></li><li>초기화 단계에서 함수 선언문을 <code>Funtion Object</code>로 생성</li><li>코드 진행 중, 아래에 이름이 같은 함수 선언문이 있으면 <code>Overriding (replace)</code>된다.</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'first'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'second'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(first()); <span class="comment">// second</span></span><br></pre></td></tr></table></figure><h3 id="Do-it"><a href="#Do-it" class="headerlink" title="Do it"></a>Do it</h3><p>다음과 같이 코드를 작성 했을 때에 예상 결과를 한번 생각해보기.</p><ol><li>함수 선언문 - <code>first()</code> - 함수 선언문</li><li>함수 표현식 - <code>second()</code> - 함수 표현식</li><li>함수 선언문 - <code>third()</code> - 함수 표현식</li><li>함수 표현식 - <code>fourth()</code> - 함수 선언문</li></ol><p><code>debugger;</code>를 통해서 실행 Context 및 순서 확인하기</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'first'</span>); &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(first());</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'first2'</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> second = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'second'</span>); &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(second());</span><br><span class="line">    <span class="keyword">var</span> second = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'second2'</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">third</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'third'</span>); &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(third());</span><br><span class="line">    <span class="keyword">var</span> third = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'third2'</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fourth = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'fourth'</span>); &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(fourth());</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fourth</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'fourth2'</span>); &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>1, 4번의 경우에는 <code>Function Overriding</code>이 일어 난다. 때문에, 함수 표현식에서의 <code>fourth</code>의 값이 JS 엔진에 의해서 초기화 될 때에 <code>undefined</code>가 아닌 이전의 함수 선언문에서 정의 했던 <code>FO</code>가 초기 값이 된다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Javascript-Function-Definition&quot;&gt;&lt;a href=&quot;#Javascript-Function-Definition&quot; class=&quot;headerlink&quot; title=&quot;Javascript Function Definition&quot;&gt;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://euntak.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://euntak.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Hoisting</title>
    <link href="http://euntak.github.io/2017/10/20/javascript-hoisting/"/>
    <id>http://euntak.github.io/2017/10/20/javascript-hoisting/</id>
    <published>2017-10-19T15:00:00.000Z</published>
    <updated>2017-11-28T14:55:55.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javascript-Hoisting"><a href="#Javascript-Hoisting" class="headerlink" title="Javascript Hoisting"></a>Javascript Hoisting</h1><p>Javscript Hoisting을 이해하기 위해서는 먼저 Javascript에서의 함수 정의 방법에 대한 이해가 필요합니다.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sports</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    <span class="keyword">var</span> player = <span class="number">11</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">soccer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> player;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> baseball = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    soccer();</span><br><span class="line">&#125;;</span><br><span class="line">sports();</span><br></pre></td></tr></table></figure><ul><li>위와 같은 코드에서 Javscript Engine은 어떻게 동작할까?<ul><li>모든 Javascript Function은 다음과 같이 동작한다.</li><li>첫번째 cycle 돌면서 <code>함수 선언문</code>을 찾아 FO(function object)을 등록</li><li>두번째 cycle 돌면서 <code>변수 (var)</code>를 찾아 <code>undefined</code>로 초기화</li><li>세번째 cycle 돌면서 JS 코드 해석 및 <code>debugger;</code> 동작</li><li>함수 선언문 해석<ul><li>function sports(){};</li></ul></li><li>변수 초기화<ul><li>var player; // undefined</li><li>var baseball; // undefined</li></ul></li><li>JS 코드 실행<ul><li>debugger;</li><li>var player = 11;</li><li>var baseball = function() {};</li></ul></li></ul></li></ul><blockquote><p>이러한 과정을 “호이스팅(Hoisting)”이라고 칭하며, “var”로 등록된 변수나, “function” 키워드로 등록된 “함수 선언문”이 JS 엔진에 의해서 해석될 때에 “위로 당겨진다(Hoisting)”라는 이유도 이러한 JS 엔진이 코드를 분석하는 특징 때문에 생겨난 개념인 것이다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Javascript-Hoisting&quot;&gt;&lt;a href=&quot;#Javascript-Hoisting&quot; class=&quot;headerlink&quot; title=&quot;Javascript Hoisting&quot;&gt;&lt;/a&gt;Javascript Hoisting&lt;/h1&gt;&lt;p&gt;Ja
      
    
    </summary>
    
      <category term="Javascript" scheme="http://euntak.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://euntak.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript에서의 This</title>
    <link href="http://euntak.github.io/2017/10/19/javascript-this/"/>
    <id>http://euntak.github.io/2017/10/19/javascript-this/</id>
    <published>2017-10-19T07:00:00.000Z</published>
    <updated>2017-11-28T14:55:55.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javscript의-This에-대해서-알아보도록-합시다"><a href="#Javscript의-This에-대해서-알아보도록-합시다" class="headerlink" title="Javscript의 This에 대해서 알아보도록 합시다"></a>Javscript의 This에 대해서 알아보도록 합시다</h1><p>Javascript를 배우면서 <code>this</code> 키워드에 대한 이해가 정말 부족하다고 느꼈었습니다. 특히나.. <code>변할 수 있기 때문</code>입니다.<br>Javascript에서 간단하게 <code>this</code>를 구별할 수 있는 방법, <code>this</code>를 적절하게 사용할 수 있는 방법에 대해서 알아둬야 할 것 같습니다.</p><h3 id="객체에서-function을-호출-할-때에-다음과-같이-합니다"><a href="#객체에서-function을-호출-할-때에-다음과-같이-합니다" class="headerlink" title="객체에서 function을 호출 할 때에 다음과 같이 합니다."></a>객체에서 function을 호출 할 때에 다음과 같이 합니다.</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app = &#123;</span><br><span class="line">    init : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (함수에서 this는 호출하는 주체) 즉, app.init()에서  `.` 앞에 함수를 호출하는 주체가 되는 것이 `this` 대상입니다.</span></span><br><span class="line">app.init();</span><br></pre></td></tr></table></figure><p>위와 같이 있을 때에, <code>init()</code> 내부의 this는 app객체가 되는 것입죠</p><h3 id="그렇다면-호출하는-주체가-없을-때의-this"><a href="#그렇다면-호출하는-주체가-없을-때의-this" class="headerlink" title="그렇다면, 호출하는 주체가 없을 때의 this"></a>그렇다면, 호출하는 주체가 없을 때의 <code>this</code></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 너는 무엇이니</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주체가 없으면 this == window</span></span><br></pre></td></tr></table></figure><p>다음과 같이 <code>setTimeout()</code>, <code>setInterval()</code>과 같은 함수 내에 callback 함수에서의 <code>this</code>는 <strong><code>window</code></strong> 객체를 가리키게 됩니다!</p><h3 id="변할-수-있는-this의-결정-시기"><a href="#변할-수-있는-this의-결정-시기" class="headerlink" title="변할 수 있는 this의 결정 시기"></a><strong>변할 수 있는 this</strong>의 결정 시기</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this는 호출 할 때에 결정 된다. 단, 한번 결정되면 함수가 종료될때까지 변경할 수 없다!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">type, legs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">  <span class="keyword">this</span>.legs = legs;</span><br><span class="line">  <span class="keyword">this</span>.logInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === myCat); <span class="comment">// =&gt; false</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The '</span> + <span class="keyword">this</span>.type + <span class="string">' has '</span> + <span class="keyword">this</span>.legs + <span class="string">' legs'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myCat = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// "The undefined has undefined legs" 출력</span></span><br><span class="line"><span class="comment">// 혹은 엄격모드라면 TypeError 출력</span></span><br><span class="line">setTimeout(myCat.logInfo, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>아마도 setTimeout으로 myCat.logInfo()를 호출할 때, myCat 객체가 출력될 거라고 예상할 수 있습니다. 하지만 setTimeout의 매개변수로 전달되었기 때문에 메소드는 객체로부터 분리 되어있고, 1초 뒤 함수 실행이 되기 때문에, logInfo가 함수로써 실행되기 때문에 여기서의 this는 전역 객체이거나 엄격 모드에서라면 undefined가 됩니다.<br>그렇기 때문에 객체의 정보를 기대한 것대로 출력하지 못합니다.</p><h2 id="this를-고정하는자-bind"><a href="#this를-고정하는자-bind" class="headerlink" title="this를 고정하는자 bind()"></a>this를 고정하는자 bind()</h2><p><code>this</code>를 고정하는 방법에는 여러가지가 있는데, 처음으로 살펴볼 아이는 <code>bind()</code>입니다.</p><p>함수는 <code>bind()</code> 메소드를 사용해 Context(문맥)을 강제로 지정시킬 수 있습니다. 아래와 같이 분리된 메소드가 myCat 객체로 바인딩 된다면 이 문제는 아주 간단하게 해결 할 수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">type, legs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">  <span class="keyword">this</span>.legs = legs;</span><br><span class="line">  <span class="keyword">this</span>.logInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === myCat); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The '</span> + <span class="keyword">this</span>.type + <span class="string">' has '</span> + <span class="keyword">this</span>.legs + <span class="string">' legs'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myCat = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// "The Cat has 4 legs" 출력</span></span><br><span class="line">setTimeout(myCat.logInfo.bind(myCat), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>myCat.logInfo.bind(myCat)는 함수 실행임에도 불구하고, bind()는 return 값이 <strong>함수</strong> 이기 때문에, 첫번째 인자로 등록된 myCat이 주체가 되어 this값을 myCat객체에 고정시켜주는 역할을 하는 것을 볼 수 있습니다.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = &#123;</span><br><span class="line">    init : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bindEvents();</span><br><span class="line">    &#125;,</span><br><span class="line">    bindEvents : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $( <span class="string">"button"</span> ).on( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 여기서의 this는 ELEMENT를 가리킵니다.</span></span><br><span class="line">            $( <span class="keyword">this</span> ).addClass( <span class="string">"active"</span> );</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        $(<span class="string">"h3"</span>).on(<span class="string">"click"</span>, <span class="keyword">this</span>.toggle.bind(<span class="keyword">this</span>, <span class="string">"name"</span>, <span class="string">"props"</span>));</span><br><span class="line">    &#125;,</span><br><span class="line">    toggle : <span class="function"><span class="keyword">function</span>(<span class="params">name, props</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name, props); <span class="comment">// "name", "props"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .bind(context, arg1, arg2, ...)</span></span><br></pre></td></tr></table></figure><p>bind()는 this를 고정하는 역할을 하지만 동시에 해당 callback 함수에 arguments들을 나열하여 필요한 정보를 전달 할 수 있습니다.</p><h3 id="this를-고정하지-않고-arguments를-보내는-방법"><a href="#this를-고정하지-않고-arguments를-보내는-방법" class="headerlink" title="this를 고정하지 않고 arguments를 보내는 방법"></a>this를 고정하지 않고 arguments를 보내는 방법</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"h3"</span>).on(<span class="string">"click"</span>, <span class="keyword">this</span>.toggle.bind(<span class="literal">undefined</span>, <span class="string">"name"</span>, <span class="string">"props"</span>));</span><br></pre></td></tr></table></figure><p>위와 같이 첫번째 인자에 undefined나, null과 같이 의미 없는 것을 인자로 전달하게 되면, this는 고정되지 않고, 인자만 전달할 수 있습니다.</p><h2 id="call-VS-apply"><a href="#call-VS-apply" class="headerlink" title="call() VS apply()"></a>call() VS apply()</h2><p>이번에는 <code>call()</code>과 <code>apply()</code>에 대해서 알아보도록 하겠습니다.<br>bind()는 return 값이 함수인 아이였습니다. 때문에, 콜백을 등록하는데에 용이 했습니다.<br>하지만, call()과 apply()는 bind()와 같이 this를 고정 함과 동시에 <code>함수를 호출</code>하는 녀석들입니다.</p><h3 id="call-과-apply-의-차이점"><a href="#call-과-apply-의-차이점" class="headerlink" title="call()과 apply()의 차이점"></a>call()과 apply()의 차이점</h3><p>간단하게 말해서 this를 고정하는건 공통이지만, 그 뒤에 bind()와 같이 인자로 정보를 넘겨줄수 있는 방식에서 차이점이 있습니다. 앞서 살펴본 bind()에서 인자를 전달하는 방법은 <code>순서대로 나열</code> 하는 방식이였습니다.</p><p>call()을 살펴볼까요?</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure><p>apply()를 살펴볼까요?</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fun.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure><p>자 이제 둘을 비교해보죠, 먼저 call()은 보시는 것 과 같이, 첫번째 인자로 thisArg를 두번째 인자부터는 arg1,2,3..을 받는 것을 확인 할 수 있습니다. 이는 bind()와 같은 형태로 인자를 받는 다는 것을 알 수 있겠네요!</p><p>한마디로 call()에서 인자를 전달하는 방법은 <code>순서대로 나열</code>하는 방식입니다.</p><p>그 다음, apply()를 살펴보면, 2개의 인자만을 받는데, 첫번째로 thisArg 두번째로는 [argsArray]를 받는 걸로 봐서 인자를 <code>배열 형태</code>로 <code>하나</code>만 받는 것을 알 수 있겠네요!</p><p>한마디로 apply()에서 인자를 전달하는 방법은 <code>여러 가지 인자를 하나의 배열 형태로 받는</code> 방식입니다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>this, bind, call, apply등을 알아봤는데, 이번 기회를 통해서 조금 애매했던 기능들의 차이점, 역할에 대해서 조금 더 명확하게 알 수 있었으면 좋겠습니다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" rel="external nofollow noopener noreferrer" target="_blank">bind</a> </li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="external nofollow noopener noreferrer" target="_blank">apply</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="external nofollow noopener noreferrer" target="_blank">call</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this" rel="external nofollow noopener noreferrer" target="_blank">this</a></li><li><a href="https://developer.mozilla.org/ko/docs/Glossary/Hoisting" rel="external nofollow noopener noreferrer" target="_blank">hoisting</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="external nofollow noopener noreferrer" target="_blank">event loop</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Javscript의-This에-대해서-알아보도록-합시다&quot;&gt;&lt;a href=&quot;#Javscript의-This에-대해서-알아보도록-합시다&quot; class=&quot;headerlink&quot; title=&quot;Javscript의 This에 대해서 알아보도록 합시다&quot;&gt;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://euntak.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://euntak.github.io/tags/Javascript/"/>
    
  </entry>
  
</feed>
