{"meta":{"title":"euntak.github.io","subtitle":"Better Than Yesterday","description":"Javascript Programmer","author":"euntak","url":"http://euntak.github.io"},"pages":[],"posts":[{"title":"Typescript Intro","slug":"typescript-basic-1","date":"2017-10-24T15:00:00.000Z","updated":"2017-12-01T06:31:51.000Z","comments":true,"path":"2017/10/25/typescript-basic-1/","link":"","permalink":"http://euntak.github.io/2017/10/25/typescript-basic-1/","excerpt":"","text":"Typescript basic Typesciprt는 무료 그리고 Microsoft(이하 MS)에서 개발 및 유지 관리하는 open-source programming language다. Javascript의 superset이며, 언어에 정적인 타입을 선택적으로 추가할 수 있는 장점이있다. HistoryTypeScript는 대규모 응용 프로그램을 개발할 때 JavaScript의 단점에서 비롯되어서 개발되었다. Javascript 짜여진 프로그램의 규모가 커지면 커질 수록, 복잡한 구조를 가질 수 밖에 없게 되고, 개발을 하는 입장에서 디버깅하기가 매우 까다로워질 수 밖에 없다. ECMA 曰 “향후에는 class-based programming에 대한 지원을 할꺼야. 이건 표준 문서에도 적혀있는 거란다.” MS에서는 ECMA의 표준을 지키며 크로스 플랫폼 지원과 호환성을 손상시키지 않는 솔루션을 찾게 되었고, Javascript의 단점들을 보완할 수 있는 추가 확장 기능들을 사용하기 위해서 Basic Javascript로 변환 하는 Compiler를 개발하게 되었다. Typescript는 MS에서 내부적으로 2년의 개발기간을 거친 후 2012년에 0.8 버전으로 처음 발표되었다.하지만 OS X와 Linux에서는 사용 할 수 없었고, 지원되는 IDE도 Microsoft Visual Studio밖에 없었기 때문에 부정적으로 평가를 받기도 했다. 하지만, 2013년에 0.9 버전이 나오면서 플러그인을 통해서 여러 IDE 및 텍스트 편집기들을(Eclipse, Sublime, Vim, Emacs 등등..) 지원할 수 있게되면서 이러한 단점들을 보완하게되었고 추가적으로 Generics도 지원하게 된다. 이 후, 2014년에 진행된 Microsoft Developer Conference에서 Typescript 1.0가 발표되었고, Visual Studio 2013은 Typescript를 built-in하는 업데이트가 되면서 본격적으로 MS의 Typescript 밀어주기가 시작된 것 같다. 2014년 7월에는 Compiler가 이전에 비해 5배의 퍼포먼스를 낼 수 있는 만큼 성능이 대폭 상승함과 동시에 CodePlex에서 관리되던 소스코드를 Github으로 옮겼다. Typescript는 지속적으로 업데이트 되어 현재 (2017.12.01) 기준 Typescript의 버전은 2.6이다. Superset History를 보면 알다시피 Typescript는 Compiled Language이기 떄문에, Typescript로 작성한 코드는 모두 Javascript로 컴파일 된다. 사실 여기서의 컴파일과 전통적인 컴파일 언어(C,C++,C#,Java…)에서의 컴파일은 차이가 있다. 그렇기 때문에 Transpile이라는 용어를 사용하기도 한다. Typescript Playground 에서 확인하면 컴파일(Transpile)된 결과물을 볼 수 있다. Why Typescript일단 Javascript에 익숙한 개발자라면 문법적으로 추가된 기능들에 대한 공부만 조금 하면 큰 허들 없이 써볼 수 있는 장점이 있는 것 같다. 또, 주관적이지만 제품을 만들때에는, 성능도 중요하지만 더 중요한건 안정성인것 같다.아무리 성능이 좋다고 하더라도 제품이 중간에 뻗는 경우가 발생하면 성능은 무용지물이지 않는가. Typescript는 정적타이핑을 통해 얻는 장점들을 Javascript에 적용할 수 있기 때문에 Javasript에 비해 안정성을 어느정도는 보장해주는 것 같다. 만약 Javascript로 대규모 어플리케이션을 만들 계획을 하고 있다면 Typescript를 추천한다. Fuatures Type Annotations and compile-time type checking Type Interface Type erasure Interfaces Enumerated type Mixin Generic Namespaces Tuple Await","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://euntak.github.io/categories/Typescript/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"http://euntak.github.io/tags/Typescript/"}]},{"title":"Javascript Function","slug":"javascript-function-definition","date":"2017-10-19T15:00:00.000Z","updated":"2017-11-28T14:55:55.537Z","comments":true,"path":"2017/10/20/javascript-function-definition/","link":"","permalink":"http://euntak.github.io/2017/10/20/javascript-function-definition/","excerpt":"","text":"Javascript Function Definition자바스크립트에서의 함수를 정의하는 방법에 대해서 알아보도록 하겠습니다. Function Declaration Function Expression new Function(param1, param2, body) 객체로 생성하기 Function Declaration (함수 선언문)function book() &#123; return 'JS';&#125; Function Expression (함수 표현식)var outside = function inside(param) &#123; if(param === 102) return param; return inside(param + 1);&#125;console.log(outside(100)); 자바스크립트 엔진이 해석하는 KEY VALUE 변경 해보면 { outside : { indide : Funtion Object } } 함수 선언문과 표현식의 차이가장 큰 차이점은 Hoisting에 있습니다. deff(); // called defffunction deff() &#123; console.log('called deff');&#125;geff(); // error!var geff = function() &#123; console.log('called geff');&#125;geff(); // called geff 위와 같은 예제에서, deff와 geff 두 함수를 호출할 때에, 함수 표현식으로 선언이 된 geff는 익명의함수가 할당된 다음에 geff()를 호출하게 되면, 정상적으로 작동이 되게 됩니다. 함수 선언문은 Function Object가 Key, Value로 등록되는 특징상 같은 실행 컨텍스트에서 함수의 이름을 중복해서 작성 할 수 없기 때문에 함수 표현식으로 Namespace를 이용해서 이와 같은 문제를 해결 할 수 있습니다. 함수 선언문은 Hoisting이 되기 때문에, Global Scope로 Function Object가 등록이 되어 어디서든지 사용할 수 있게 되고, 함수 표현식은 Hoisting이 되지 않기 때문에, 해당 변수에 함수를 할당하는 과정 이후에만 사용 할 수 있다. 함수 선언문 오버라이딩함수 이름이 같을 때 함수 코드 대체 (replace) JS는 파라미터 수, 데이터 타입을 체크하지 않는다 Why? Function Object는 {key : value} 형식으로 저장되기 때문 고로 Function Signiture는 Only 함수 이름 초기화 단계에서 함수 선언문을 Funtion Object로 생성 코드 진행 중, 아래에 이름이 같은 함수 선언문이 있으면 Overriding (replace)된다. function first() &#123; console.log('first');&#125;function first(i) &#123; console.log('second');&#125;console.log(first()); // second Do it다음과 같이 코드를 작성 했을 때에 예상 결과를 한번 생각해보기. 함수 선언문 - first() - 함수 선언문 함수 표현식 - second() - 함수 표현식 함수 선언문 - third() - 함수 표현식 함수 표현식 - fourth() - 함수 선언문 debugger;를 통해서 실행 Context 및 순서 확인하기 window.onload(function () &#123; debugger; function first() &#123; console.log('first'); &#125;; console.log(first()); function first() &#123; console.log('first2'); &#125;; var second = function () &#123; console.log('second'); &#125;; console.log(second()); var second = function () &#123; console.log('second2'); &#125;; function third() &#123; console.log('third'); &#125;; console.log(third()); var third = function() &#123; console.log('third2'); &#125;; var fourth = function () &#123; console.log('fourth'); &#125;; console.log(fourth()); function fourth () &#123; console.log('fourth2'); &#125;;&#125;); 1, 4번의 경우에는 Function Overriding이 일어 난다. 때문에, 함수 표현식에서의 fourth의 값이 JS 엔진에 의해서 초기화 될 때에 undefined가 아닌 이전의 함수 선언문에서 정의 했던 FO가 초기 값이 된다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://euntak.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://euntak.github.io/tags/Javascript/"}]},{"title":"Javascript Hoisting","slug":"javascript-hoisting","date":"2017-10-19T15:00:00.000Z","updated":"2017-11-28T14:55:55.537Z","comments":true,"path":"2017/10/20/javascript-hoisting/","link":"","permalink":"http://euntak.github.io/2017/10/20/javascript-hoisting/","excerpt":"","text":"Javascript HoistingJavscript Hoisting을 이해하기 위해서는 먼저 Javascript에서의 함수 정의 방법에 대한 이해가 필요합니다. function sports() &#123; debugger; var player = 11; function soccer() &#123; return player; &#125; var baseball = function() &#123;&#125;; soccer();&#125;;sports(); 위와 같은 코드에서 Javscript Engine은 어떻게 동작할까? 모든 Javascript Function은 다음과 같이 동작한다. 첫번째 cycle 돌면서 함수 선언문을 찾아 FO(function object)을 등록 두번째 cycle 돌면서 변수 (var)를 찾아 undefined로 초기화 세번째 cycle 돌면서 JS 코드 해석 및 debugger; 동작 함수 선언문 해석 function sports(){}; 변수 초기화 var player; // undefined var baseball; // undefined JS 코드 실행 debugger; var player = 11; var baseball = function() {}; 이러한 과정을 “호이스팅(Hoisting)”이라고 칭하며, “var”로 등록된 변수나, “function” 키워드로 등록된 “함수 선언문”이 JS 엔진에 의해서 해석될 때에 “위로 당겨진다(Hoisting)”라는 이유도 이러한 JS 엔진이 코드를 분석하는 특징 때문에 생겨난 개념인 것이다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://euntak.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://euntak.github.io/tags/Javascript/"}]},{"title":"Javascript에서의 This","slug":"javascript-this","date":"2017-10-19T07:00:00.000Z","updated":"2017-11-28T14:55:55.537Z","comments":true,"path":"2017/10/19/javascript-this/","link":"","permalink":"http://euntak.github.io/2017/10/19/javascript-this/","excerpt":"","text":"Javscript의 This에 대해서 알아보도록 합시다Javascript를 배우면서 this 키워드에 대한 이해가 정말 부족하다고 느꼈었습니다. 특히나.. 변할 수 있기 때문입니다.Javascript에서 간단하게 this를 구별할 수 있는 방법, this를 적절하게 사용할 수 있는 방법에 대해서 알아둬야 할 것 같습니다. 객체에서 function을 호출 할 때에 다음과 같이 합니다.app = &#123; init : function() &#123; console.log(this); &#125;&#125;// (함수에서 this는 호출하는 주체) 즉, app.init()에서 `.` 앞에 함수를 호출하는 주체가 되는 것이 `this` 대상입니다.app.init(); 위와 같이 있을 때에, init() 내부의 this는 app객체가 되는 것입죠 그렇다면, 호출하는 주체가 없을 때의 thissetTimeout(function() &#123; console.log(this); // 너는 무엇이니&#125;, 1000);// 주체가 없으면 this == window 다음과 같이 setTimeout(), setInterval()과 같은 함수 내에 callback 함수에서의 this는 window 객체를 가리키게 됩니다! 변할 수 있는 this의 결정 시기// this는 호출 할 때에 결정 된다. 단, 한번 결정되면 함수가 종료될때까지 변경할 수 없다!function Animal(type, legs) &#123; this.type = type; this.legs = legs; this.logInfo = function() &#123; console.log(this === myCat); // =&gt; false console.log('The ' + this.type + ' has ' + this.legs + ' legs'); &#125;&#125;var myCat = new Animal('Cat', 4);// \"The undefined has undefined legs\" 출력// 혹은 엄격모드라면 TypeError 출력setTimeout(myCat.logInfo, 1000); 아마도 setTimeout으로 myCat.logInfo()를 호출할 때, myCat 객체가 출력될 거라고 예상할 수 있습니다. 하지만 setTimeout의 매개변수로 전달되었기 때문에 메소드는 객체로부터 분리 되어있고, 1초 뒤 함수 실행이 되기 때문에, logInfo가 함수로써 실행되기 때문에 여기서의 this는 전역 객체이거나 엄격 모드에서라면 undefined가 됩니다.그렇기 때문에 객체의 정보를 기대한 것대로 출력하지 못합니다. this를 고정하는자 bind()this를 고정하는 방법에는 여러가지가 있는데, 처음으로 살펴볼 아이는 bind()입니다. 함수는 bind() 메소드를 사용해 Context(문맥)을 강제로 지정시킬 수 있습니다. 아래와 같이 분리된 메소드가 myCat 객체로 바인딩 된다면 이 문제는 아주 간단하게 해결 할 수 있습니다. function Animal(type, legs) &#123; this.type = type; this.legs = legs; this.logInfo = function() &#123; console.log(this === myCat); // =&gt; true console.log('The ' + this.type + ' has ' + this.legs + ' legs'); &#125;;&#125;var myCat = new Animal('Cat', 4);// \"The Cat has 4 legs\" 출력setTimeout(myCat.logInfo.bind(myCat), 1000); myCat.logInfo.bind(myCat)는 함수 실행임에도 불구하고, bind()는 return 값이 함수 이기 때문에, 첫번째 인자로 등록된 myCat이 주체가 되어 this값을 myCat객체에 고정시켜주는 역할을 하는 것을 볼 수 있습니다. var Module = &#123; init : function() &#123; this.bindEvents(); &#125;, bindEvents : function() &#123; $( \"button\" ).on( \"click\", function () &#123; // 여기서의 this는 ELEMENT를 가리킵니다. $( this ).addClass( \"active\" ); &#125;); $(\"h3\").on(\"click\", this.toggle.bind(this, \"name\", \"props\")); &#125;, toggle : function(name, props) &#123; console.log(name, props); // \"name\", \"props\" &#125;&#125;// .bind(context, arg1, arg2, ...) bind()는 this를 고정하는 역할을 하지만 동시에 해당 callback 함수에 arguments들을 나열하여 필요한 정보를 전달 할 수 있습니다. this를 고정하지 않고 arguments를 보내는 방법$(\"h3\").on(\"click\", this.toggle.bind(undefined, \"name\", \"props\")); 위와 같이 첫번째 인자에 undefined나, null과 같이 의미 없는 것을 인자로 전달하게 되면, this는 고정되지 않고, 인자만 전달할 수 있습니다. call() VS apply()이번에는 call()과 apply()에 대해서 알아보도록 하겠습니다.bind()는 return 값이 함수인 아이였습니다. 때문에, 콜백을 등록하는데에 용이 했습니다.하지만, call()과 apply()는 bind()와 같이 this를 고정 함과 동시에 함수를 호출하는 녀석들입니다. call()과 apply()의 차이점간단하게 말해서 this를 고정하는건 공통이지만, 그 뒤에 bind()와 같이 인자로 정보를 넘겨줄수 있는 방식에서 차이점이 있습니다. 앞서 살펴본 bind()에서 인자를 전달하는 방법은 순서대로 나열 하는 방식이였습니다. call()을 살펴볼까요? fun.call(thisArg[, arg1[, arg2[, ...]]]) apply()를 살펴볼까요? fun.apply(thisArg, [argsArray]) 자 이제 둘을 비교해보죠, 먼저 call()은 보시는 것 과 같이, 첫번째 인자로 thisArg를 두번째 인자부터는 arg1,2,3..을 받는 것을 확인 할 수 있습니다. 이는 bind()와 같은 형태로 인자를 받는 다는 것을 알 수 있겠네요! 한마디로 call()에서 인자를 전달하는 방법은 순서대로 나열하는 방식입니다. 그 다음, apply()를 살펴보면, 2개의 인자만을 받는데, 첫번째로 thisArg 두번째로는 [argsArray]를 받는 걸로 봐서 인자를 배열 형태로 하나만 받는 것을 알 수 있겠네요! 한마디로 apply()에서 인자를 전달하는 방법은 여러 가지 인자를 하나의 배열 형태로 받는 방식입니다. 정리this, bind, call, apply등을 알아봤는데, 이번 기회를 통해서 조금 애매했던 기능들의 차이점, 역할에 대해서 조금 더 명확하게 알 수 있었으면 좋겠습니다. 참고 bind apply call this hoisting event loop","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://euntak.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://euntak.github.io/tags/Javascript/"}]}]}