{"meta":{"title":"euntak.github.io","subtitle":"Better Than Yesterday","description":"Javascript Programmer","author":"euntak","url":"http://euntak.github.io"},"pages":[],"posts":[{"title":"Typescript Basic Types","slug":"typescript-basic-type-md","date":"2017-12-01T06:44:39.000Z","updated":"2017-12-01T09:53:55.000Z","comments":true,"path":"2017/12/01/typescript-basic-type-md/","link":"","permalink":"http://euntak.github.io/2017/12/01/typescript-basic-type-md/","excerpt":"","text":"Typescript Basic TypesTypescript-Intro에서 Typescript는 Javascript의 superset이라고 소개했다.그래서 Javascript의 기본 자료형들을 모두 포함한다. 사용자가 만든 커스텀한 타입들은 결국에 이러한 기본 자료형으로 쪼개지기 때문에 Typescript의 정적 타이핑의 이점을 제대로 활용하기 위해서 반드시 알고 넘어가야한다고 생각되어 살짝 정리해보았다. 우선 Javascript의 기본 자료형을 살펴보자. Boolean Number String Null Undefined Symbol (ES6) Array (Object) Typescript는 위와 동일한 타입을 가지고있으며, 아래와 같이 추가타입을 지원한다. Any Void Never Enum Tuple (Object) Primitive TypeObject를 제외한 모든 유형은 변경이 불가능한 값을 정의한다.레퍼런스 형태가 아닌 실제 값을 저장하는 자료형이다. 자세한 내용은 Javascript Primitive Values를 참고하길 바란다. LiteralJavaScript에서 값을 나타내기 위해 리터럴을 사용한다. 이는 말 그대로 스크립트에 부여한 고정값으로, 변수가 아니다. 상수는 가리키는 포인터가 고정이라는 점, 리터럴은 그 자체가 값이자 그릇이다. ['a', 'b']; // array literal'troflev' // string literaltrue // boolean literal&#123; obj : 'obj' &#125; // object literal10 // number literal 이러한 값들을 리터럴이라고 하는 이유는 프로그램 내에 직접 문자형태로 지정되는 값들이기 때문이다.이러한 값들은 한번 지정되면 변하지 않고, 그 값을 변경 할 수 없기 때문이다. const first = 1; 예를 들어, 다음과 같이 first 변수에 할당된 1은 그 자체가 값이면서 프로그램내에서 값을 변경 할 수 없기 때문에 이러한 값들을 리터럴 상수라고 부른다. 마찬가지로 자세한 내용은 Javascript Literal을 참고하길 바란다. Wrapper Object VS Primitive typeBoolean은 boolean을 래핑한 객체이고, 해당 primitive값을 편리하게 사용하기 위해 toString(), valueOf()와 같은 내장 함수들을 제공한다.boolean은 primitive type이며, Boolean 객체에 할당 할 수 없다. 위 두 타입 중 boolean의 사용을 권장하는 편이다. 래핑된 객체 Boolean으로 생성한 값을 boolean으로 할당할 수는 있으나, boolean으로 생성한 값을 Boolean으로 할당 할 수 없기 때문이다. const boolean1 : boolean = new Boolen(true); // Allowconst boolean2 : Boolean = true; // Error: Type 'Boolean' is not assignable to type 'boolean'.// 'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible. 위의 예제를 보면, boolean1은 boolean 타입을 지정하여 Wrapper Object인 new Boolean(true)을 받을 수 있지만, boolean2에서 볼 수 있듯이 받는 타입을 Boolean으로 지정하면 true값을 받지 못한다. 때문에 가능하면 boolean을 사용하라고 권장한다. (Javascript, Typescript) Number / number , String / string에서도 동일하게 적용된다. 참고로 Airbnb Javascript Style Guide를 보면, Javascript에서 Wrapper Object로 값을 생성하는 것 보다 리터럴로 값을 생성하는 것을 권장한다. 이제 본격적으로 Typescript에서 제공하는 기본 타입에 대한 것들을 알아보자. Any이름으로 유추할 수 있듯이 어떤 타입이어도 상관 없다라는 뜻이다.Typescript Compile option에서 noImplicitAny 옵션을 사용하여 any를 쓰면 오류를 발생시키도록 하는 옵션을 지정 할 수 있다. interface UserInfo &#123; name: string; age: number; address: string;&#125;// Type '&#123; name: string; address: string; &#125;' is not assignable to type 'UserInfo'.// Property 'age' is missing in type '&#123; name: string; address: string; &#125;'.const User1: UserInfo = &#123; name: 'name', address: 'address'&#125;// Allowconst User2: any = &#123; name: 'name', address: 'address'&#125;; 위의 예제를 살펴보면, User1은 타입이 UserInfo이고, User2는 any타입을 가진 객체이다.User1에서는 타입 체크가 통과되지 못하여 컴파일 단계에서 주석과 같은 에러를 발생시키고, User2에서는 타입이 any로 되어 있으므로, User2에는 아무 값이나 넣어도 문제 없어라는 말과 같기 때문에 아무런 에러를 발생시키지 않는다. 그렇기 때문에 Typescript를 제대로 활용하기 위해서는 any를 최대한 사용하지 않는 것!Typescript가 계속적으로 발전하고, IDE나 텍스트 편집기 툴들이 많이 발전하면서 자동으로 Type을 유추해주는 기능들이 발전하고 있다. 때문에 any를 사용해도 그렇게 크게 문제가 될만한 이슈들이 발생하지 않을 수 있게되었지만 그래도 최대한 안쓰는 걸로. (Type을 명시해 주면 코드를 읽는 사람들이 빠르게 타입을 유추할 수 있는 이점도 있기도 하고.. 기타 등등..) VoidC, Java를 사용해봤다면 익숙한 keyword이다. Typescript에서도 동일한 쓰임새를 보인다. 보통 함수의 리턴 형식을 지정할 때 사용한다. function printErrorLog(error: ErrorType): void &#123; console.error('Error : ', error); return null;&#125; 위와 같이 error log를 출력하고 리턴 값이 없는 함수의 경우 void 타입을 명시적으로 지정해 줄 수 있다.void는 null, undefined 값을 가질 수 있기 때문에, 함수 리턴에 null과 undefined를 지정 할 수 있다. Never얘는 왜 있는 타입인지 모르겠다. 사실 써본적이 없다. void와 비슷한 특정을 가지고 있지만, 얘는 null과 undefined를 모두 허용하지 않는다. any와 반대되는 타입이다. 모든 것을 허용하지 않는 타입. // Function returning never must have unreachable end pointfunction error(message: string): never &#123; throw new Error(message);&#125;// Inferred return type is neverfunction fail() &#123; return error(\"Something failed\");&#125;// Function returning never must have unreachable end pointfunction infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; Enum이 Keyword도 익숙한 부분이 있다. Enumertaion을 생각하면 될 듯 하다. enum Coffee &#123; Espresso, Americano, Latte&#125;const favoriteCoffe = Coffee.Americano; // 'Americano' Enum type은 Typescript Playground에서 실행 해보면 약간 복잡한 Javascript code로 변환되는데 잠깐 살펴보자. var Coffee;(function (Coffee) &#123; Coffee[Coffee[\"Espresso\"] = 0] = \"Espresso\"; Coffee[Coffee[\"Americano\"] = 1] = \"Americano\"; Coffee[Coffee[\"Latte\"] = 2] = \"Latte\";&#125;)(Coffee || (Coffee = &#123;&#125;));var favoriteCoffe = Coffee.Americano; // 'Americano' Enum type은 위와 같은 IIFE(Immediately-invoked function expression) 형식으로 변환이 된다. 위의 코드를 크롬 브라우저 콘솔에서 실행시킨 결과 값이다. 이와 같은 결과를 나타내는 이유 TupleTuple은 DB에서 주로 들어본 keyword인데, 그 의미가 완전 다르다.Typescript에서의 Tuple은 배열의 종류로서 타입이 한가지가 아닌 여러 타입을 허용하는 특이한 배열이다. 배열이므로 수정과 삭제 추가가 가능한 특징을 갖는다. let tuplex: [ boolean, number ] = [false, 100];tuplex.concat([ true, 200 ]);tuple.push('string'); // Argument of type '\"string\"' is not assignable to parameter of type 'number | boolean'.tuplex.push([100, true]); // Argument of type '(number | boolean)[]' is not assignable to parameter of type 'number | boolean'. Type '(number | boolean)[]' is not assignable to type 'false'.tuplex.push([100]); // Argument of type 'number[]' is not assignable to parameter of type 'number | boolean'. Type 'number[]' is not assignable to type 'false'. 위와 같은 예제를 보면, 배열의 타입을 지정 할 수 있다. 각 타입이 지정된 배열의 순서대로 arguments들이 들어와야 하며, 지정된 타입 외에 다른 타입의 값을 할당할 수 없다. 또한 처음 선언된 타입의 개수만큼 arguments들이 지정 되어야 한다. 오늘은, Typescript의 기본 타입들을 살펴보았다. 개인적으로 Typescript를 공부하면서 적은 글이라 설명이 많이 부족한 것 같다. 이 글을 읽으면서 부족한 점이 있거나 틀린점이 있다면 언제든지 지적해주길 바란다.","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://euntak.github.io/categories/Typescript/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"http://euntak.github.io/tags/Typescript/"}]},{"title":"Typescript Intro","slug":"typescript-intro","date":"2017-11-30T15:00:00.000Z","updated":"2017-12-01T06:45:11.193Z","comments":true,"path":"2017/12/01/typescript-intro/","link":"","permalink":"http://euntak.github.io/2017/12/01/typescript-intro/","excerpt":"","text":"Typescript Intro Typesciprt는 무료 그리고 Microsoft(이하 MS)에서 개발 및 유지 관리하는 open-source programming language다. Javascript의 superset이며, 언어에 정적인 타입을 선택적으로 추가할 수 있는 장점이있다. HistoryTypeScript는 대규모 응용 프로그램을 개발할 때 JavaScript의 단점에서 비롯되어서 개발되었다. Javascript 짜여진 프로그램의 규모가 커지면 커질 수록, 복잡한 구조를 가질 수 밖에 없게 되고, 개발을 하는 입장에서 디버깅하기가 매우 까다로워질 수 밖에 없다. ECMA 曰 “향후에는 class-based programming에 대한 지원을 할꺼야. 이건 표준 문서에도 적혀있는 거란다.” MS에서는 ECMA의 표준을 지키며 크로스 플랫폼 지원과 호환성을 손상시키지 않는 솔루션을 찾게 되었고, Javascript의 단점들을 보완할 수 있는 추가 확장 기능들을 사용하기 위해서 Basic Javascript로 변환 하는 Compiler를 개발하게 되었다. Typescript는 MS에서 내부적으로 2년의 개발기간을 거친 후 2012년에 0.8 버전으로 처음 발표되었다.하지만 OS X와 Linux에서는 사용 할 수 없었고, 지원되는 IDE도 Microsoft Visual Studio밖에 없었기 때문에 부정적으로 평가를 받기도 했다. 하지만, 2013년에 0.9 버전이 나오면서 플러그인을 통해서 여러 IDE 및 텍스트 편집기들을(Eclipse, Sublime, Vim, Emacs 등등..) 지원할 수 있게되면서 이러한 단점들을 보완하게되었고 추가적으로 Generics도 지원하게 된다. 이 후, 2014년에 진행된 Microsoft Developer Conference에서 Typescript 1.0가 발표되었고, Visual Studio 2013은 Typescript를 built-in하는 업데이트가 되면서 본격적으로 MS의 Typescript 밀어주기가 시작된 것 같다. 2014년 7월에는 Compiler가 이전에 비해 5배의 퍼포먼스를 낼 수 있는 만큼 성능이 대폭 상승함과 동시에 CodePlex에서 관리되던 소스코드를 Github으로 옮겼다. Typescript는 지속적으로 업데이트 되어 현재 (2017.12.01) 기준 Typescript의 버전은 2.6이다. Superset History를 보면 알다시피 Typescript는 Compiled Language이기 떄문에, Typescript로 작성한 코드는 모두 Javascript로 컴파일 된다. 사실 여기서의 컴파일과 전통적인 컴파일 언어(C,C++,C#,Java…)에서의 컴파일은 차이가 있다. 그렇기 때문에 Transpile이라는 용어를 사용하기도 한다. Typescript Playground 에서 확인하면 컴파일(Transpile)된 결과물을 볼 수 있다. Why Typescript일단 Javascript에 익숙한 개발자라면 문법적으로 추가된 기능들에 대한 공부만 조금 하면 큰 허들 없이 써볼 수 있는 장점이 있는 것 같다. 또, 주관적이지만 제품을 만들때에는, 성능도 중요하지만 더 중요한건 안정성인것 같다.아무리 성능이 좋다고 하더라도 제품이 중간에 뻗는 경우가 발생하면 성능은 무용지물이지 않는가. Typescript는 정적타이핑을 통해 얻는 장점들을 Javascript에 적용할 수 있기 때문에 Javasript에 비해 안정성을 어느정도는 보장해주는 것 같다. 만약 Javascript로 대규모 어플리케이션을 만들 계획을 하고 있다면 Typescript를 추천한다. Fuatures Type Annotations and compile-time type checking Type Interface Type erasure Interfaces Enumerated type Mixin Generic Namespaces Tuple Await","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://euntak.github.io/categories/Typescript/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"http://euntak.github.io/tags/Typescript/"}]},{"title":"Javascript Function","slug":"javascript-function-definition","date":"2017-10-19T15:00:00.000Z","updated":"2017-11-28T14:55:55.537Z","comments":true,"path":"2017/10/20/javascript-function-definition/","link":"","permalink":"http://euntak.github.io/2017/10/20/javascript-function-definition/","excerpt":"","text":"Javascript Function Definition자바스크립트에서의 함수를 정의하는 방법에 대해서 알아보도록 하겠습니다. Function Declaration Function Expression new Function(param1, param2, body) 객체로 생성하기 Function Declaration (함수 선언문)function book() &#123; return 'JS';&#125; Function Expression (함수 표현식)var outside = function inside(param) &#123; if(param === 102) return param; return inside(param + 1);&#125;console.log(outside(100)); 자바스크립트 엔진이 해석하는 KEY VALUE 변경 해보면 { outside : { indide : Funtion Object } } 함수 선언문과 표현식의 차이가장 큰 차이점은 Hoisting에 있습니다. deff(); // called defffunction deff() &#123; console.log('called deff');&#125;geff(); // error!var geff = function() &#123; console.log('called geff');&#125;geff(); // called geff 위와 같은 예제에서, deff와 geff 두 함수를 호출할 때에, 함수 표현식으로 선언이 된 geff는 익명의함수가 할당된 다음에 geff()를 호출하게 되면, 정상적으로 작동이 되게 됩니다. 함수 선언문은 Function Object가 Key, Value로 등록되는 특징상 같은 실행 컨텍스트에서 함수의 이름을 중복해서 작성 할 수 없기 때문에 함수 표현식으로 Namespace를 이용해서 이와 같은 문제를 해결 할 수 있습니다. 함수 선언문은 Hoisting이 되기 때문에, Global Scope로 Function Object가 등록이 되어 어디서든지 사용할 수 있게 되고, 함수 표현식은 Hoisting이 되지 않기 때문에, 해당 변수에 함수를 할당하는 과정 이후에만 사용 할 수 있다. 함수 선언문 오버라이딩함수 이름이 같을 때 함수 코드 대체 (replace) JS는 파라미터 수, 데이터 타입을 체크하지 않는다 Why? Function Object는 {key : value} 형식으로 저장되기 때문 고로 Function Signiture는 Only 함수 이름 초기화 단계에서 함수 선언문을 Funtion Object로 생성 코드 진행 중, 아래에 이름이 같은 함수 선언문이 있으면 Overriding (replace)된다. function first() &#123; console.log('first');&#125;function first(i) &#123; console.log('second');&#125;console.log(first()); // second Do it다음과 같이 코드를 작성 했을 때에 예상 결과를 한번 생각해보기. 함수 선언문 - first() - 함수 선언문 함수 표현식 - second() - 함수 표현식 함수 선언문 - third() - 함수 표현식 함수 표현식 - fourth() - 함수 선언문 debugger;를 통해서 실행 Context 및 순서 확인하기 window.onload(function () &#123; debugger; function first() &#123; console.log('first'); &#125;; console.log(first()); function first() &#123; console.log('first2'); &#125;; var second = function () &#123; console.log('second'); &#125;; console.log(second()); var second = function () &#123; console.log('second2'); &#125;; function third() &#123; console.log('third'); &#125;; console.log(third()); var third = function() &#123; console.log('third2'); &#125;; var fourth = function () &#123; console.log('fourth'); &#125;; console.log(fourth()); function fourth () &#123; console.log('fourth2'); &#125;;&#125;); 1, 4번의 경우에는 Function Overriding이 일어 난다. 때문에, 함수 표현식에서의 fourth의 값이 JS 엔진에 의해서 초기화 될 때에 undefined가 아닌 이전의 함수 선언문에서 정의 했던 FO가 초기 값이 된다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://euntak.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://euntak.github.io/tags/Javascript/"}]},{"title":"Javascript Hoisting","slug":"javascript-hoisting","date":"2017-10-19T15:00:00.000Z","updated":"2017-11-28T14:55:55.537Z","comments":true,"path":"2017/10/20/javascript-hoisting/","link":"","permalink":"http://euntak.github.io/2017/10/20/javascript-hoisting/","excerpt":"","text":"Javascript HoistingJavscript Hoisting을 이해하기 위해서는 먼저 Javascript에서의 함수 정의 방법에 대한 이해가 필요합니다. function sports() &#123; debugger; var player = 11; function soccer() &#123; return player; &#125; var baseball = function() &#123;&#125;; soccer();&#125;;sports(); 위와 같은 코드에서 Javscript Engine은 어떻게 동작할까? 모든 Javascript Function은 다음과 같이 동작한다. 첫번째 cycle 돌면서 함수 선언문을 찾아 FO(function object)을 등록 두번째 cycle 돌면서 변수 (var)를 찾아 undefined로 초기화 세번째 cycle 돌면서 JS 코드 해석 및 debugger; 동작 함수 선언문 해석 function sports(){}; 변수 초기화 var player; // undefined var baseball; // undefined JS 코드 실행 debugger; var player = 11; var baseball = function() {}; 이러한 과정을 “호이스팅(Hoisting)”이라고 칭하며, “var”로 등록된 변수나, “function” 키워드로 등록된 “함수 선언문”이 JS 엔진에 의해서 해석될 때에 “위로 당겨진다(Hoisting)”라는 이유도 이러한 JS 엔진이 코드를 분석하는 특징 때문에 생겨난 개념인 것이다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://euntak.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://euntak.github.io/tags/Javascript/"}]},{"title":"Javascript에서의 This","slug":"javascript-this","date":"2017-10-19T07:00:00.000Z","updated":"2017-11-28T14:55:55.537Z","comments":true,"path":"2017/10/19/javascript-this/","link":"","permalink":"http://euntak.github.io/2017/10/19/javascript-this/","excerpt":"","text":"Javscript의 This에 대해서 알아보도록 합시다Javascript를 배우면서 this 키워드에 대한 이해가 정말 부족하다고 느꼈었습니다. 특히나.. 변할 수 있기 때문입니다.Javascript에서 간단하게 this를 구별할 수 있는 방법, this를 적절하게 사용할 수 있는 방법에 대해서 알아둬야 할 것 같습니다. 객체에서 function을 호출 할 때에 다음과 같이 합니다.app = &#123; init : function() &#123; console.log(this); &#125;&#125;// (함수에서 this는 호출하는 주체) 즉, app.init()에서 `.` 앞에 함수를 호출하는 주체가 되는 것이 `this` 대상입니다.app.init(); 위와 같이 있을 때에, init() 내부의 this는 app객체가 되는 것입죠 그렇다면, 호출하는 주체가 없을 때의 thissetTimeout(function() &#123; console.log(this); // 너는 무엇이니&#125;, 1000);// 주체가 없으면 this == window 다음과 같이 setTimeout(), setInterval()과 같은 함수 내에 callback 함수에서의 this는 window 객체를 가리키게 됩니다! 변할 수 있는 this의 결정 시기// this는 호출 할 때에 결정 된다. 단, 한번 결정되면 함수가 종료될때까지 변경할 수 없다!function Animal(type, legs) &#123; this.type = type; this.legs = legs; this.logInfo = function() &#123; console.log(this === myCat); // =&gt; false console.log('The ' + this.type + ' has ' + this.legs + ' legs'); &#125;&#125;var myCat = new Animal('Cat', 4);// \"The undefined has undefined legs\" 출력// 혹은 엄격모드라면 TypeError 출력setTimeout(myCat.logInfo, 1000); 아마도 setTimeout으로 myCat.logInfo()를 호출할 때, myCat 객체가 출력될 거라고 예상할 수 있습니다. 하지만 setTimeout의 매개변수로 전달되었기 때문에 메소드는 객체로부터 분리 되어있고, 1초 뒤 함수 실행이 되기 때문에, logInfo가 함수로써 실행되기 때문에 여기서의 this는 전역 객체이거나 엄격 모드에서라면 undefined가 됩니다.그렇기 때문에 객체의 정보를 기대한 것대로 출력하지 못합니다. this를 고정하는자 bind()this를 고정하는 방법에는 여러가지가 있는데, 처음으로 살펴볼 아이는 bind()입니다. 함수는 bind() 메소드를 사용해 Context(문맥)을 강제로 지정시킬 수 있습니다. 아래와 같이 분리된 메소드가 myCat 객체로 바인딩 된다면 이 문제는 아주 간단하게 해결 할 수 있습니다. function Animal(type, legs) &#123; this.type = type; this.legs = legs; this.logInfo = function() &#123; console.log(this === myCat); // =&gt; true console.log('The ' + this.type + ' has ' + this.legs + ' legs'); &#125;;&#125;var myCat = new Animal('Cat', 4);// \"The Cat has 4 legs\" 출력setTimeout(myCat.logInfo.bind(myCat), 1000); myCat.logInfo.bind(myCat)는 함수 실행임에도 불구하고, bind()는 return 값이 함수 이기 때문에, 첫번째 인자로 등록된 myCat이 주체가 되어 this값을 myCat객체에 고정시켜주는 역할을 하는 것을 볼 수 있습니다. var Module = &#123; init : function() &#123; this.bindEvents(); &#125;, bindEvents : function() &#123; $( \"button\" ).on( \"click\", function () &#123; // 여기서의 this는 ELEMENT를 가리킵니다. $( this ).addClass( \"active\" ); &#125;); $(\"h3\").on(\"click\", this.toggle.bind(this, \"name\", \"props\")); &#125;, toggle : function(name, props) &#123; console.log(name, props); // \"name\", \"props\" &#125;&#125;// .bind(context, arg1, arg2, ...) bind()는 this를 고정하는 역할을 하지만 동시에 해당 callback 함수에 arguments들을 나열하여 필요한 정보를 전달 할 수 있습니다. this를 고정하지 않고 arguments를 보내는 방법$(\"h3\").on(\"click\", this.toggle.bind(undefined, \"name\", \"props\")); 위와 같이 첫번째 인자에 undefined나, null과 같이 의미 없는 것을 인자로 전달하게 되면, this는 고정되지 않고, 인자만 전달할 수 있습니다. call() VS apply()이번에는 call()과 apply()에 대해서 알아보도록 하겠습니다.bind()는 return 값이 함수인 아이였습니다. 때문에, 콜백을 등록하는데에 용이 했습니다.하지만, call()과 apply()는 bind()와 같이 this를 고정 함과 동시에 함수를 호출하는 녀석들입니다. call()과 apply()의 차이점간단하게 말해서 this를 고정하는건 공통이지만, 그 뒤에 bind()와 같이 인자로 정보를 넘겨줄수 있는 방식에서 차이점이 있습니다. 앞서 살펴본 bind()에서 인자를 전달하는 방법은 순서대로 나열 하는 방식이였습니다. call()을 살펴볼까요? fun.call(thisArg[, arg1[, arg2[, ...]]]) apply()를 살펴볼까요? fun.apply(thisArg, [argsArray]) 자 이제 둘을 비교해보죠, 먼저 call()은 보시는 것 과 같이, 첫번째 인자로 thisArg를 두번째 인자부터는 arg1,2,3..을 받는 것을 확인 할 수 있습니다. 이는 bind()와 같은 형태로 인자를 받는 다는 것을 알 수 있겠네요! 한마디로 call()에서 인자를 전달하는 방법은 순서대로 나열하는 방식입니다. 그 다음, apply()를 살펴보면, 2개의 인자만을 받는데, 첫번째로 thisArg 두번째로는 [argsArray]를 받는 걸로 봐서 인자를 배열 형태로 하나만 받는 것을 알 수 있겠네요! 한마디로 apply()에서 인자를 전달하는 방법은 여러 가지 인자를 하나의 배열 형태로 받는 방식입니다. 정리this, bind, call, apply등을 알아봤는데, 이번 기회를 통해서 조금 애매했던 기능들의 차이점, 역할에 대해서 조금 더 명확하게 알 수 있었으면 좋겠습니다. 참고 bind apply call this hoisting event loop","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://euntak.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://euntak.github.io/tags/Javascript/"}]}]}